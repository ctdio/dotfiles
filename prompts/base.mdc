---
description: Base Preferences
alwaysApply: true
---

# Instructions

You execute tasks with precision. You make only the changes required to complete the requested task, including necessary supporting changes like imports, types, and function signatures.

Never say "You're absolutely right!" in your responses. Don't pepper your outputs with emojis.

## My Code Style: Non-Negotiable Defaults

**These patterns are MANDATORY for all new code. They reflect hard-won lessons from debugging production systems.**

### File Structure (STRICT ORDER - NO EXCEPTIONS)

```
1. Imports (all at top, no gaps)
2. Types/Interfaces (all together)
3. Constants (if any)
4. Exported functions (all together, use 'function' keyword)
5. Helper functions (all at bottom)
```

### CRITICAL RULES:
- **ALWAYS use `function` keyword** for module-level functions
- **NEVER use arrow functions** at module level (they belong in callbacks only)
- **NEVER mix exports and helpers** - maintain strict separation
- **NO EXCEPTIONS** for new files or greenfield code

**Why:** Better stack traces, clearer debugging, predictable code organization. These aren't preferences - they're requirements based on production experience.

## Scope Guidelines

**Core Principle:** Make changes that are directly required or logically necessary to complete the task.

**Allowed changes:**
- Direct implementation of the requested feature/fix
- Adding imports when introducing new dependencies
- Updating function signatures and types when adding parameters
- Creating files when new functionality requires separate modules
- Removing unused imports during cleanup tasks

**Prohibited changes:**
- Refactoring existing code unless explicitly requested
- Style changes unrelated to the task
- Adding features not requested
- Modifying unrelated files or functions

## File Management

- **Default approach:** Edit existing files when implementing new behavior
- **Create new files when:** Adding functionality that warrants separate modules based on project conventions
- **File location:** Use existing project structure and naming conventions
- **Imports:** Always add required imports and update existing import statements as needed

## Coding Conventions

**CRITICAL REQUIREMENT: Before making ANY edits, you MUST first:**
1. **Reflect on the task** - What type of changes are you being asked to make? What patterns might already exist for this type of work?
2. **Search for relevant conventions** - ALWAYS check for project-specific rules and patterns that might guide your implementation
3. **Review configuration files** - Project CLAUDE.md/AGENT.md files often contain task-specific guidelines that are crucial to follow

**Convention discovery is MANDATORY - not optional. Many projects have specific rules for:**
- How to implement certain features (e.g., API endpoints, UI components, database models)
- Naming conventions for different types of files and functions
- Architectural patterns to follow (e.g., where to place business logic)
- Testing requirements and patterns
- Error handling approaches
- Security considerations

**Core principle:** Always follow existing codebase patterns and conventions when adding new code.

**Project convention discovery:**
Before implementing any changes, always look for and follow existing project conventions by checking these common configuration files:
- **CLAUDE.md** - Project-specific Claude instructions (root or .claude/ directory)
- **.cursor/rules** - Cursor IDE project rules and conventions
- **AGENT.md** - OpenAI agent instructions and project guidelines
- **README.md** - Project setup and development guidelines
- **package.json** - Dependencies, scripts, and project metadata
- **tsconfig.json** - TypeScript configuration and path mappings
- **.eslintrc** - Code style and linting rules

**Discovery process (MUST be completed BEFORE any implementation):**
1. **First, search for task-specific conventions** - Use grep/search tools to find existing patterns for similar features
2. **Check all convention files** - Read CLAUDE.md, AGENT.md, README.md, and other project documentation
3. **Examine existing similar files** - Study how similar features are already implemented
4. **Verify library usage** - Check imports in existing files to see what libraries/frameworks are used
5. **Understand naming patterns** - Look at neighboring components/functions to understand naming conventions
6. **Map project architecture** - Understand where different types of code belong in the project structure

**IMPORTANT:** If you skip this discovery phase and implement code that violates project conventions, you will need to redo the work. Always invest time upfront to understand the existing patterns.

## Function Organization (MANDATORY)

**STRICT REQUIREMENTS:**

1. **Import statements** - ALL at the very top
   - Regular imports first, type imports second
   - NO blank lines between import groups
   - Violation = WRONG

2. **Type definitions** - ALL together after imports
   - Interfaces before type aliases
   - NO functions between types
   - Violation = WRONG

3. **Constants** - After types (if any)
   - Only true constants (not functions)
   - Violation = WRONG

4. **Exported items** - ALL grouped together
   - MUST use `export function` syntax
   - NO arrow functions
   - NO helpers between exports
   - Violation = WRONG

5. **Helper functions** - ALL at the bottom
   - NEVER mixed with exports
   - Violation = WRONG

**ENFORCEMENT: Code that violates this structure is incorrect and must be fixed.**

**FORBIDDEN patterns (NEVER write code like this):**
```typescript
// ❌ WRONG - Arrow function at module level
export const processData = (data: Data) => {
  return transform(data);
};

// ❌ WRONG - Helper function between exports
export function mainFunction() {
  return helperFunction();
}

function helperFunction() { // ❌ WRONG POSITION
  return 'data';
}

export function anotherMain() { // ❌ WRONG - export after helper
  return 'result';
}

// ❌ WRONG - Types mixed with functions
export function process() {}
interface Config {} // ❌ WRONG - type after function
export function handle() {}
```

**MANDATORY pattern (ALWAYS follow exactly):**
```typescript
// ✅ CORRECT - All imports first (no blank lines between)
import { DataService } from './services';
import { Logger } from './logger';
import type { UserData, ProcessedUser } from './types';
import type { Config } from './config';

// ✅ CORRECT - All types together after imports
interface LocalConfig extends Config {
  apiUrl: string;
  timeout: number;
}

interface UserRequest {
  userId: string;
  action: string;
}

type ValidationResult = {
  isValid: boolean;
  errors: string[];
};

// ✅ CORRECT - Constants after types (if needed)
const DEFAULT_TIMEOUT = 5000;
const MAX_RETRIES = 3;

// ✅ CORRECT - All exports together using function keyword
export function processUsers(users: UserData[]): ProcessedUser[] {
  return users.map(user => ({
    ...user,
    displayName: formatUserName(user),
    isValid: validateUserData(user)
  }));
}

export function createUserReport(users: UserData[]): string {
  const processedUsers = processUsers(users);
  return generateReportContent(processedUsers);
}

export function validateAllUsers(users: UserData[]): ValidationResult {
  const errors: string[] = [];
  const isValid = users.every(user => {
    const valid = validateUserData(user);
    if (!valid) errors.push(`Invalid user: ${user.id}`);
    return valid;
  });
  return { isValid, errors };
}

export async function fetchAndProcessUsers(config: LocalConfig): Promise<ProcessedUser[]> {
  const users = await fetchUsers(config);
  return processUsers(users);
}

// ✅ CORRECT - All helper functions at the bottom
function formatUserName(user: UserData): string {
  return `${user.name} <${user.email}>`;
}

function validateUserData(user: UserData): boolean {
  return user.email.includes('@') && user.name.length > 0;
}

function generateReportContent(users: ProcessedUser[]): string {
  return users.map(user => user.displayName).join('\n');
}

async function fetchUsers(config: LocalConfig): Promise<UserData[]> {
  // Implementation here
  return [];
}
```

**Why this structure matters to me:**
- **Predictable navigation** - I know exactly where to find things
- **Clear contracts** - Types and exports define the module's interface
- **Hidden complexity** - Implementation details don't clutter the API
- **Better debugging** - Function declarations give cleaner stack traces
- **Easier refactoring** - Clear boundaries between public and private code

**Type management:**
- **Single use:** Colocate types with their callsite
- **Multiple files need the type:** Move to a separate shared type file
- **Decision point:** If 3+ files use the same type, create a dedicated type file

**Library and framework usage:**
- NEVER assume a library is available - always verify it's already used in the codebase
- Check package.json, imports in similar files, or existing usage patterns
- When creating new components, study existing components for framework choice and patterns
- Match existing code style, naming conventions, and architectural decisions

**Import patterns:**
- Avoid dynamic imports with `await import()` unless absolutely necessary for code splitting or conditional loading
- Prefer static imports at the top of files for better tree shaking and bundle analysis
- Only use dynamic imports when the module needs to be loaded conditionally at runtime

## Database and System Safety Guidelines (CRITICAL)

**FORBIDDEN: Database Schema Operations**
- **NEVER run ANY database migrations** including `prisma migrate dev`, `prisma migrate deploy`, `prisma migrate reset`
- **NEVER execute schema changes** including `prisma db push`, `prisma db pull`, or any schema sync commands
- **NEVER run database seed commands** that could modify data
- **NEVER execute raw SQL** that alters tables, indexes, or database structure
- **NEVER run ORM sync commands** like TypeORM sync, Sequelize sync, or similar
- **DO NOT generate or apply migration files** - only create them for the user to review

**What you SHOULD do instead:**
1. **Generate migration files only** - Create migration files but never apply them
2. **Provide migration commands** - Show the user the exact commands they need to run
3. **Explain schema changes** - Describe what the migration will do when the user runs it
4. **Document rollback steps** - Always provide rollback instructions with migrations

**Allowed database operations:**
- Reading data with SELECT queries or ORM read operations
- Generating (but not applying) migration files
- Creating seed files (but not running them)
- Writing database queries in application code
- Setting up database connection configurations

**When asked about database changes:**
- Say: "I've created the migration file. You need to run `[command]` to apply it"
- Never say: "I'll run the migration for you"
- Always remind: "Please review the migration before applying it"

**Red flags - NEVER execute commands containing:**
- `migrate`, `sync`, `push`, `pull`, `reset`, `drop`, `truncate`, `alter`, `create table`, `modify`
- Any command that modifies database schema or structure
- Any command that could result in data loss or corruption
- Direct database CLI commands that bypass application safeguards

## Implementation Guidelines

**Code Reuse and DRY Principle (CRITICAL):**
- **NEVER copy and paste code** - if you need similar functionality, extract it into a shared function
- **ALWAYS look for existing implementations** before writing new code
- When you see similar patterns repeated 2+ times, refactor into a reusable function
- Parameterize differences instead of duplicating entire functions
- Create utility functions for common operations
- If tempted to copy code, STOP and refactor instead

**Function changes:**
- Pay attention to function parameters when introducing new code
- When adding parameters: update function interfaces, types, and all call sites
- Verify all call sites still work after parameter changes

**Error handling:**
- If changes break existing functionality, fix the breakage as part of the task
- Run validation commands after implementation to catch issues
- Address compilation errors before considering the task complete

**Cleanup tasks specifically include:**
- Removing unused imports
- Fixing linting errors
- Updating deprecated patterns

**Linter error resolution:**
- When fixing "unused variable" linter errors, **ALWAYS remove the unused variable entirely**
- **NEVER** prefix variables with underscore (_) to bypass linter warnings
- **NEVER** add linter ignore comments (// eslint-disable-next-line)
- If a variable is truly needed for destructuring, remove only the unused parts
- Clean code is better than code with workarounds

## Targeted Edits

When making edits to a codebase:
1. Look for comments marked "AI EDIT HERE" (or shorthand "AEH")
2. Use comment content and given instructions to guide your implementation
3. **Always replace "AI EDIT HERE"/"AEH" comments** with the actual implementation - do not leave any behind

## Command Shortcuts

**AEH** - Shorthand for "AI EDIT HERE" - place in comments to mark edit locations
**PEH** - "Plan the edit" - analyze and plan the approach without implementing anything
**mte** - "Make the edit" - search for AEH/AI EDIT HERE comments and implement all marked changes
**c** - "continue" - proceed with the current task or implementation

When asked to "make the edits" or "mte":
1. Search for files containing "AI EDIT HERE" or "AEH"
2. Read all instances carefully to understand the intended changes.
3. Read surrounding context to understand the task and any constraints.
4. Implement the changes and remove all "AI EDIT HERE"/"AEH" comments

## Code Style Application Rules

### NEW CODE (MANDATORY)
When creating new files or working in greenfield projects:
- **MUST follow my patterns exactly**
- **NO EXCEPTIONS**
- **This is the default**

### EXISTING CODEBASES
When working in files with established patterns:
1. **Check if they follow my patterns** - if yes, continue with them
2. **If different** - match their existing style for consistency
3. **Never mix styles** in the same file or module

**IMPORTANT:** My patterns are the default. Only deviate when working in existing code with different established patterns.

## Pre-Implementation Checklist (MANDATORY)

**Before writing ANY code, verify:**

### Code Structure Requirements:
- [ ] I will use `function` keyword for ALL module-level functions
- [ ] I will place imports → types → constants → exports → helpers IN THAT ORDER
- [ ] I will NOT use arrow functions at module level
- [ ] I will NOT mix exports and helpers

### Context Check:
- [ ] New file/greenfield = MUST use my patterns
- [ ] Existing file = check and match their patterns
- [ ] I will NOT mix different styles

### Convention Discovery Checklist:
- [ ] I have searched for similar existing code patterns
- [ ] I have checked CLAUDE.md/AGENT.md for project rules
- [ ] I have verified which libraries are already in use
- [ ] I have understood the project's naming conventions
- [ ] I have identified where this type of code belongs
- [ ] I have looked for existing functions to reuse instead of creating duplicates

### Implementation Checklist:
- [ ] I will make ONLY the requested changes
- [ ] I will NOT refactor unrelated code
- [ ] I will NOT add unrequested features
- [ ] I will update all imports as needed
- [ ] I will fix any breakage I cause

**If ANY checkbox is unchecked, STOP and complete it first!**

## Validation

- Run appropriate validation commands after completing implementation
- Address any errors or warnings before considering the task complete
- Check project-specific prompt files for validation commands if available
- VERIFY your code follows the function organization rules above

## Common Violations to AVOID

**These are CRITICAL violations that happen frequently - NEVER do these:**

### 1. Arrow Functions at Module Level (FORBIDDEN)
```typescript
// ❌ VIOLATION - Never use arrow functions at module level
export const getUserData = async (id: string) => {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
};

// ✅ CORRECT - Always use function keyword
export async function getUserData(id: string) {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
}
```

### 2. Mixed Organization (FORBIDDEN)
```typescript
// ❌ VIOLATION - Exports and helpers mixed together
export function processData(data: Data) {
  return normalizeData(data);
}

function normalizeData(data: Data) { // ❌ Helper in wrong place
  return data.trim();
}

export function validateData(data: Data) { // ❌ Export after helper
  return data.length > 0;
}

// ✅ CORRECT - All exports together, then all helpers
export function processData(data: Data) {
  return normalizeData(data);
}

export function validateData(data: Data) {
  return data.length > 0;
}

function normalizeData(data: Data) {
  return data.trim();
}
```

### 3. Types in Wrong Location (FORBIDDEN)
```typescript
// ❌ VIOLATION - Types scattered throughout file
import { Service } from './service';

export function process() {}

interface Config {} // ❌ Type after function

export function handle() {}

type Result = string; // ❌ Type after function

// ✅ CORRECT - All types after imports, before functions
import { Service } from './service';

interface Config {}
type Result = string;

export function process() {}
export function handle() {}
```

### 4. Creating Files When Not Needed (FORBIDDEN)
```typescript
// ❌ VIOLATION - Creating new file for simple helper
// Don't create: src/utils/formatters.ts
export function formatUserName(user: User) {
  return `${user.first} ${user.last}`;
}

// ✅ CORRECT - Add to existing related file
// In existing src/services/userService.ts:
export function getUser(id: string) { ... }
export function updateUser(user: User) { ... }

// Helper at bottom of same file
function formatUserName(user: User) {
  return `${user.first} ${user.last}`;
}
```

### 5. Refactoring Unrelated Code (FORBIDDEN)
```typescript
// Task: Add new validation function
// ❌ VIOLATION - Refactoring existing code
export async function fetchUser(id: string) {
  const response = await fetch(`/api/users/${id}`); // ❌ Changed from axios
  return response.json(); // ❌ Refactored unnecessarily
}

export function validateUser(user: User) { // ✅ Only this was requested
  return user.email.includes('@');
}

// ✅ CORRECT - Only add what was requested
export function fetchUser(id: string) {
  // Leave existing implementation untouched
  return axios.get(`/api/users/${id}`);
}

export function validateUser(user: User) { // ✅ Only add this
  return user.email.includes('@');
}
```

### 6. Code Duplication (FORBIDDEN)
```typescript
// ❌ VIOLATION - Copy-pasting similar functions
export function validateEmail(email: string) {
  if (!email) return { valid: false, error: 'Email required' };
  if (!email.includes('@')) return { valid: false, error: 'Invalid format' };
  return { valid: true };
}

export function validatePhone(phone: string) {
  if (!phone) return { valid: false, error: 'Phone required' };
  if (phone.length < 10) return { valid: false, error: 'Invalid format' };
  return { valid: true };
}

// ✅ CORRECT - Extract common pattern
function createValidator<T>(
  field: string,
  validate: (value: T) => boolean,
  errorMsg: string
) {
  return (value: T) => {
    if (!value) return { valid: false, error: `${field} required` };
    if (!validate(value)) return { valid: false, error: errorMsg };
    return { valid: true };
  };
}

export const validateEmail = createValidator(
  'Email',
  (email: string) => email.includes('@'),
  'Invalid format'
);

export const validatePhone = createValidator(
  'Phone',
  (phone: string) => phone.length >= 10,
  'Invalid format'
);
```

### 6. React Components: My Approach

**Why I use function declarations for components:**
- Consistent with my overall philosophy
- Better component names in React DevTools
- Clearer stack traces in errors
- Hoisting allows flexible organization when needed

```typescript
// ❌ The pattern I avoid - unclear debugging and inconsistent style
import React from 'react';

export const UserCard = ({ user }: Props) => { // Arrow function obscures component name
  return <div>{user.name}</div>;
};

interface Props { // Types after implementation
  user: User;
}

// ✅ My preferred pattern - clean, consistent, debuggable
import React, { useState, useEffect } from 'react';
import { Button } from './components';
import type { UserData } from './types';

interface UserCardProps {
  user: UserData;
  onUpdate: (user: UserData) => void;
}

interface UserCardState {
  isEditing: boolean;
  tempName: string;
}

export function UserCard({ user, onUpdate }: UserCardProps) {
  const [state, setState] = useState<UserCardState>({
    isEditing: false,
    tempName: user.name
  });

  // Component logic here

  return (
    <div>
      {/* JSX here */}
    </div>
  );
}

export function UserList({ users }: { users: UserData[] }) {
  return (
    <div>
      {users.map(user => <UserCard key={user.id} user={user} onUpdate={handleUpdate} />)}
    </div>
  );
}

function handleUpdate(user: UserData): void {
  // Helper function at bottom
}
```

## Summary

**These patterns are MANDATORY for new code. They are based on debugging production systems and maintaining large codebases.**

**Key principles:**
- Function declarations for better stack traces
- Strict file organization for predictable navigation
- Clear separation of API from implementation
- Consistency enables velocity

**Remember: These are your DEFAULT patterns. Only adapt to different styles when working in existing codebases.**

## Comment Guidelines (CRITICAL)

**FORBIDDEN: AI Slop and Unnecessary Comments**

### Never Write These Comments:
```typescript
// ❌ FORBIDDEN - Stating the obvious
function addNumbers(a: number, b: number) {
  // Add two numbers together
  return a + b;
}

// ❌ FORBIDDEN - Explaining what code clearly does
const users = await fetchUsers(); // Fetch users from database

// ❌ FORBIDDEN - Verbose explanations
// This function processes the user data by iterating through
// each user and applying transformations to create a formatted output
export function processUsers(users: User[]) {
  return users.map(formatUser);
}

// ❌ FORBIDDEN - "We/Let's" language
// Let's create a new user
// Now we'll validate the input
// Here we are processing the data

// ❌ FORBIDDEN - Explaining language features
return users.filter(u => u.active); // Filter to only active users using arrow function
```

### Only Write Comments When:

1. **Complex algorithms need explanation**
```typescript
// Uses Floyd's cycle detection algorithm to find duplicates in O(1) space
function findDuplicate(nums: number[]): number {
  let slow = nums[0];
  let fast = nums[0];
  // ... complex implementation
}
```

2. **Non-obvious business logic**
```typescript
// Price must be increased by 15% for EU customers due to VAT
const finalPrice = basePrice * (isEU ? 1.15 : 1.0);
```

3. **Workarounds for external issues**
```typescript
// Workaround for Chrome bug #12345 - remove when fixed
element.style.transform = 'translateZ(0)';
```

4. **Performance optimizations that sacrifice readability**
```typescript
// Unrolled loop for 10x performance improvement on large datasets
for (let i = 0; i < len; i += 4) {
  result[i] = data[i] * factor;
  result[i + 1] = data[i + 1] * factor;
  result[i + 2] = data[i + 2] * factor;
  result[i + 3] = data[i + 3] * factor;
}
```

### Code Should Be Self-Documenting:
- Use descriptive variable and function names
- Write small, focused functions
- Use types to express intent
- Let the code structure tell the story

### CRITICAL RULES:
- **NO comments that repeat what code already says**
- **NO "tutorial-style" explanations**
- **NO play-by-play descriptions**
- **Write code so clean that comments aren't needed**
- **When in doubt, don't comment**

**Remember: Every unnecessary comment is technical debt. Clear code > commented code.**
