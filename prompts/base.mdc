---
description: Base Preferences
alwaysApply: true
---

# Instructions

You execute tasks with precision. You make only the changes required to complete the requested task, including necessary supporting changes like imports, types, and function signatures.

Never say "You're absolutely right!" in your responses. Don't pepper your outputs with emojis.

## My Code Style: Non-Negotiable Defaults

**PRINCIPLE: Code should read like a book - main story first, supporting details follow.**

### File Structure
```
1. Imports (all at top, no gaps)
2. Types/Interfaces (all together)
3. Constants (if any)
4. Main exports - the "what" this module does
5. Implementation details - the "how" it works
```

### CRITICAL RULES:
- **ALWAYS use `function` keyword** for module-level functions
- **NEVER use arrow functions** at module level (callbacks only)
- **Order functions for readability** - main purpose immediately visible
- **Function declarations give cleaner stack traces**

## Scope Guidelines

**Core Principle:** Make changes directly required to complete the task.

**SURGICAL EDITING:** When modifying existing code, make the smallest possible change that achieves the goal. Touch only the specific lines/functions that need modification.

**FILE EDITING BEHAVIOR (CRITICAL):**
- **ALWAYS edit existing files directly** - NEVER create "-improved", "-enhanced", "-v2", "-new", or similar versions
- **FORBIDDEN:** Creating copies/variants of existing files with suffixes like "-updated", "-fixed", "-refactored"
- **REQUIRED:** Use Edit/MultiEdit tools to modify files in place
- **Exception:** Only create new files when genuinely adding new functionality, not improving existing code

**Allowed:** Direct implementation, necessary imports/types, file creation when warranted, cleanup tasks
**Prohibited:** Unrelated refactoring, style changes, unrequested features, modifying unrelated code, creating file variants

## Refactoring and Backwards Compatibility (CRITICAL)

**DEFAULT BEHAVIOR: NO backwards compatibility preservation**

**When refactoring exports:**
- **REMOVE old exports** when replacing with new ones
- **DO NOT maintain deprecated exports** for backwards compatibility
- **DO NOT create compatibility shims or aliases**
- **ONLY preserve old exports if explicitly requested**

**Examples:**
```typescript
// ❌ WRONG - Don't do this unless asked
export function newFunction() { ... }
export const oldFunction = newFunction; // Backwards compat

// ✅ CORRECT - Clean refactor
export function newFunction() { ... }
// Old export removed entirely
```

**If backwards compatibility is needed, user will explicitly say:** "maintain backwards compatibility", "keep old exports", "preserve existing API"

## Coding Conventions

**MANDATORY Discovery Process (before ANY implementation):**
1. Search for task-specific conventions in existing code
2. Check CLAUDE.md, AGENT.md, README.md, package.json, tsconfig.json
3. Study similar existing features
4. Verify library usage in existing files
5. Understand naming patterns and project architecture

**IMPORTANT:** Skipping discovery means redoing work. Always understand existing patterns first.

## Function Organization - Top-Down Flow

**KEY INSIGHT: Readers should understand module purpose from first few exports, not after scrolling through helpers.**

**CORRECT Pattern:**
```typescript
// All imports first (no blank lines between)
import { DataService } from './services';
import type { UserData, ProcessedUser } from './types';

// All types together
interface LocalConfig {
  apiUrl: string;
  timeout: number;
}

// Constants (if needed)
const DEFAULT_TIMEOUT = 5000;

// Main exports - purpose immediately clear
export async function fetchAndProcessUsers(config: LocalConfig): Promise<ProcessedUser[]> {
  const users = await fetchUsers(config);
  return processUsers(users);
}

export function processUsers(users: UserData[]): ProcessedUser[] {
  return users.map(user => ({
    ...user,
    displayName: formatUserName(user)
  }));
}

// Helper functions at bottom
function formatUserName(user: UserData): string {
  return `${user.name} <${user.email}>`;
}

async function fetchUsers(config: LocalConfig): Promise<UserData[]> {
  // Implementation
  return [];
}
```

**Type management:** Single use = colocate; 3+ files = shared type file

**Library usage:** NEVER assume availability - verify in package.json and existing imports

**Import patterns:** Static imports only (no `await import()` except for route splitting)

## Database and System Safety (CRITICAL)

**FORBIDDEN:** 
- Running migrations (`prisma migrate`, `db push`, etc.)
- Executing schema changes or raw SQL altering structure
- Running seed commands

**ALLOWED:** 
- Generating (not applying) migration files
- Reading data with SELECT/ORM reads
- Creating seed files (not running them)

**When asked about DB changes:** "I've created the migration file. You need to run `[command]` to apply it"

## Server Management (CRITICAL)

**FORBIDDEN:** Starting dev servers without explicit request (`npm run dev`, `yarn start`, etc.)

**When explicitly asked:** Confirm command, start server, monitor output

## Git Commit Management (CRITICAL)

**FORBIDDEN:** Creating git commits without explicit request (`git commit`, `git add`, etc.)

**NEVER commit changes unless the user explicitly asks you to.** It is VERY IMPORTANT to only commit when explicitly asked, otherwise the user will feel that you are being too proactive.

**When explicitly asked to commit:** Follow proper commit message conventions, stage appropriate files, create commit

## Implementation Planning

**When creating implementation plans:**
- **NEVER provide day or time estimates** (no "this will take X hours/days")
- **Focus on task breakdown** - List concrete steps and dependencies
- **Identify complexity** through technical details, not time
- **Describe effort** using relative terms: "straightforward", "complex", "requires careful consideration"
- **Highlight risks** and technical challenges without time implications

**Good planning format:**
```
1. Clear action items with technical specifics
2. Dependencies and prerequisites identified
3. Potential challenges or edge cases noted
4. Testing and validation steps included
```

**Avoid:**
- "This will take 2 days"
- "Approximately 4-6 hours"
- "Should be done by tomorrow"
- Any calendar or clock references

## Implementation Guidelines

**Code Reuse (CRITICAL):**
- NEVER copy/paste code - extract shared functions
- Look for existing implementations first
- Refactor when patterns repeat 2+ times

**Error handling:** Fix breakage as part of task

**Linter errors:** Remove unused variables entirely (no underscore prefix or ignore comments)

## Targeted Edits

**AI EDIT HERE / AEH:** Mark locations for implementation, always replace with actual code

## Command Shortcuts

- **AEH** - "AI EDIT HERE" marker
- **PEH** - Plan without implementing
- **mte** - Make all marked edits
- **c** - Continue
- **TODO** - Add to todo list

## Code Style Application

**New code:** MUST follow my patterns exactly
**Existing code:** Match their patterns for consistency
**Never mix styles in same file**

## Pre-Implementation Checklist

- [ ] Use `function` keyword for module-level functions
- [ ] Organize top-down: main purpose first
- [ ] Check existing conventions before writing
- [ ] Make ONLY requested changes
- [ ] Fix any breakage caused

## Common Violations to AVOID

1. **Arrow functions at module level** - Use `function` keyword
2. **Poor organization** - Main exports first, helpers last
3. **Types scattered** - All types after imports
4. **Creating file variants** - NEVER create "-improved", "-enhanced", "-v2" versions; edit files directly
5. **Creating unnecessary files** - Edit existing when possible
6. **Unrelated refactoring** - Only requested changes
7. **Code duplication** - Extract shared functions
8. **Maintaining backwards compatibility** - Remove old exports unless explicitly asked

## React Components

```typescript
// Imports
import React, { useState } from 'react';
import type { UserData } from './types';

// Types
interface UserCardProps {
  user: UserData;
  onUpdate: (user: UserData) => void;
}

// Component with function keyword
export function UserCard({ user, onUpdate }: UserCardProps) {
  const [isEditing, setIsEditing] = useState(false);
  
  return <div>{/* JSX */}</div>;
}

// Helpers at bottom
function validateUserData(data: unknown): data is UserData {
  // validation
}
```

## Comment Guidelines

**FORBIDDEN:** Obvious comments, explaining what code clearly does, "we/let's" language

**ONLY comment when:** Complex algorithms, non-obvious business logic, workarounds, performance optimizations

**Code should be self-documenting through clear naming and structure.**