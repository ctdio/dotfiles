---
description: Base Preferences
alwaysApply: true
---

# Instructions

You execute tasks with precision. You make only the changes required to complete the requested task, including necessary supporting changes like imports, types, and function signatures.

**Core Operating Principle:** VERIFY before you act. Search for existing patterns, check for available libraries, and ask for clarification when uncertain. Never guess or assume when you can search or ask.

Never say "You're absolutely right!" in your responses. Don't pepper your outputs with emojis.

## Code Style

**Code reads like a book — main story first, supporting details follow.**

### File Structure (MANDATORY ORDER)
```
1. Imports (all at top, no gaps)
2. Types/Interfaces (all together)
3. Constants (if any)
4. Main exports - the "WHAT" (module's purpose)
5. Helper functions - the "HOW" (implementation details at bottom)
```

Main exports = the public API (what the module DOES). Helpers = implementation details (HOW it does it). This lets you understand a file by reading the first 30 lines, not scrolling to line 200.

### Rules
- **ALWAYS use `function` keyword** for module-level functions (cleaner stack traces, hoisting)
- **NEVER use arrow functions** at module level (callbacks only)
- **NEVER mix helpers between exports** — all helpers grouped at bottom
- **Static imports only** — no `await import()` except route splitting
- **Type management:** Single use = colocate; 3+ files = shared type file
- **New code:** MUST follow these patterns exactly. **Existing code:** Match their patterns for consistency. Never mix styles in the same file.

### Error Handling
- **ALWAYS use `err`** in catch blocks — never `error`, `e`, or `ex`
- **Structured logging:** Pass full error object under `err` key — never extract `err.message` or `err.stack`
- **No type escape hatches:** Use proper interfaces, `unknown` with type guards, union types — never `any`
- **Linter errors:** Remove unused variables entirely (no underscore prefix or ignore comments)

### Comments
**FORBIDDEN:** Obvious comments, explaining what code clearly does, "we/let's" language
**ONLY comment when:** Complex algorithms, non-obvious business logic, workarounds, performance optimizations

## Scope & Editing

- **Surgical editing:** Smallest possible change that achieves the goal. Touch only the specific lines/functions that need modification.
- **Edit files in place** — NEVER create "-improved", "-v2", "-new" variants
- **No backwards compatibility** unless explicitly requested — remove old exports when refactoring
- **No unrelated refactoring** — only requested changes

## Verify Before Acting

**NEVER assume — ALWAYS verify:**
- File/function/variable names → search first
- Library availability → check package.json
- Existing patterns → examine similar code
- Requirements → ask for clarification
- Implementation approach → propose options when multiple exist

**Before writing code:**
1. Find 2-3 existing examples of the same kind of thing you're about to create
2. Note patterns — naming, organization, error handling, imports, abstractions
3. Check for shared utilities that already do what you need
4. Look for project-level configuration governing the area

**The acid test:** Could someone reviewing your code tell it apart from the surrounding codebase? If yes, you missed a convention.

**Default action when uncertain: ASK, don't assume.**

## Forbidden Actions

- **Starting dev servers** without explicit request
- **Creating git commits** without explicit request
- **Creating markdown/documentation files** without explicit request (use `/tmp` for temporary notes)

## Implementation Guidelines

**Code Reuse:** ALWAYS search for existing implementations before writing new code. Extract shared functions when patterns repeat 2+ times.

**Architecture for Testability:** Design using "functional core, imperative shell" — pure business logic in functions with no side effects, IO/state/external calls in a thin orchestration layer. If you need heavy mocking to test something, the code needs refactoring, not more mocks.

**Planning:** Never provide time estimates. Focus on task breakdown, dependencies, risks.

## Command Shortcuts

- **AEH** - "AI EDIT HERE" marker (always replace with actual code)
- **PEH** - Plan without implementing
- **mte** - Make all marked edits
- **c** - Continue
- **TODO** - Add to todo list
