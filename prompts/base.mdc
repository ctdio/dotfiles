---
description: Base Preferences
alwaysApply: true
---

# Instructions

You execute tasks with precision. You make only the changes required to complete the requested task, including necessary supporting changes like imports, types, and function signatures.

Never say "You're absolutely right!" in your responses. Don't pepper your outputs with emojis.

## My Code Style: Non-Negotiable Defaults

**PRINCIPLE: Code should read like a book - main story first, supporting details follow.**

### File Structure
```
1. Imports (all at top, no gaps)
2. Types/Interfaces (all together)
3. Constants (if any)
4. Main exports - the "what" this module does
5. Implementation details - the "how" it works
```

### CRITICAL RULES:
- **ALWAYS use `function` keyword** for module-level functions
- **NEVER use arrow functions** at module level (callbacks only)
- **Order functions for readability** - main purpose immediately visible
- **Function declarations give cleaner stack traces**

## Scope Guidelines

**Core Principle:** Make changes directly required to complete the task.

**Allowed:** Direct implementation, necessary imports/types, file creation when warranted, cleanup tasks
**Prohibited:** Unrelated refactoring, style changes, unrequested features, modifying unrelated code

## Coding Conventions

**MANDATORY Discovery Process (before ANY implementation):**
1. Search for task-specific conventions in existing code
2. Check CLAUDE.md, AGENT.md, README.md, package.json, tsconfig.json
3. Study similar existing features
4. Verify library usage in existing files
5. Understand naming patterns and project architecture

**IMPORTANT:** Skipping discovery means redoing work. Always understand existing patterns first.

## Function Organization - Top-Down Flow

**KEY INSIGHT: Readers should understand module purpose from first few exports, not after scrolling through helpers.**

**CORRECT Pattern:**
```typescript
// All imports first (no blank lines between)
import { DataService } from './services';
import type { UserData, ProcessedUser } from './types';

// All types together
interface LocalConfig {
  apiUrl: string;
  timeout: number;
}

// Constants (if needed)
const DEFAULT_TIMEOUT = 5000;

// Main exports - purpose immediately clear
export async function fetchAndProcessUsers(config: LocalConfig): Promise<ProcessedUser[]> {
  const users = await fetchUsers(config);
  return processUsers(users);
}

export function processUsers(users: UserData[]): ProcessedUser[] {
  return users.map(user => ({
    ...user,
    displayName: formatUserName(user)
  }));
}

// Helper functions at bottom
function formatUserName(user: UserData): string {
  return `${user.name} <${user.email}>`;
}

async function fetchUsers(config: LocalConfig): Promise<UserData[]> {
  // Implementation
  return [];
}
```

**Type management:** Single use = colocate; 3+ files = shared type file

**Library usage:** NEVER assume availability - verify in package.json and existing imports

**Import patterns:** Static imports only (no `await import()` except for route splitting)

## Database and System Safety (CRITICAL)

**FORBIDDEN:** 
- Running migrations (`prisma migrate`, `db push`, etc.)
- Executing schema changes or raw SQL altering structure
- Running seed commands

**ALLOWED:** 
- Generating (not applying) migration files
- Reading data with SELECT/ORM reads
- Creating seed files (not running them)

**When asked about DB changes:** "I've created the migration file. You need to run `[command]` to apply it"

## Server Management (CRITICAL)

**FORBIDDEN:** Starting dev servers without explicit request (`npm run dev`, `yarn start`, etc.)

**When explicitly asked:** Confirm command, start server, monitor output

## Git Commit Management (CRITICAL)

**FORBIDDEN:** Creating git commits without explicit request (`git commit`, `git add`, etc.)

**NEVER commit changes unless the user explicitly asks you to.** It is VERY IMPORTANT to only commit when explicitly asked, otherwise the user will feel that you are being too proactive.

**When explicitly asked to commit:** Follow proper commit message conventions, stage appropriate files, create commit

## Implementation Guidelines

**Code Reuse (CRITICAL):**
- NEVER copy/paste code - extract shared functions
- Look for existing implementations first
- Refactor when patterns repeat 2+ times

**Error handling:** Fix breakage as part of task

**Linter errors:** Remove unused variables entirely (no underscore prefix or ignore comments)

## Targeted Edits

**AI EDIT HERE / AEH:** Mark locations for implementation, always replace with actual code

## Command Shortcuts

- **AEH** - "AI EDIT HERE" marker
- **PEH** - Plan without implementing
- **mte** - Make all marked edits
- **c** - Continue
- **TODO** - Add to todo list

## Code Style Application

**New code:** MUST follow my patterns exactly
**Existing code:** Match their patterns for consistency
**Never mix styles in same file**

## Pre-Implementation Checklist

- [ ] Use `function` keyword for module-level functions
- [ ] Organize top-down: main purpose first
- [ ] Check existing conventions before writing
- [ ] Make ONLY requested changes
- [ ] Fix any breakage caused

## Common Violations to AVOID

1. **Arrow functions at module level** - Use `function` keyword
2. **Poor organization** - Main exports first, helpers last
3. **Types scattered** - All types after imports
4. **Creating unnecessary files** - Edit existing when possible
5. **Unrelated refactoring** - Only requested changes
6. **Code duplication** - Extract shared functions

## React Components

```typescript
// Imports
import React, { useState } from 'react';
import type { UserData } from './types';

// Types
interface UserCardProps {
  user: UserData;
  onUpdate: (user: UserData) => void;
}

// Component with function keyword
export function UserCard({ user, onUpdate }: UserCardProps) {
  const [isEditing, setIsEditing] = useState(false);
  
  return <div>{/* JSX */}</div>;
}

// Helpers at bottom
function validateUserData(data: unknown): data is UserData {
  // validation
}
```

## Comment Guidelines

**FORBIDDEN:** Obvious comments, explaining what code clearly does, "we/let's" language

**ONLY comment when:** Complex algorithms, non-obvious business logic, workarounds, performance optimizations

**Code should be self-documenting through clear naming and structure.**