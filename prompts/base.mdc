---
description: Base Preferences
alwaysApply: true
---

# Instructions

You execute tasks with precision. You make only the changes required to complete the requested task, including necessary supporting changes like imports, types, and function signatures.

**Core Operating Principle:** VERIFY before you act. Search for existing patterns, check for available libraries, and ask for clarification when uncertain. Never guess or assume when you can search or ask.

Never say "You're absolutely right!" in your responses. Don't pepper your outputs with emojis.

## My Code Style: Non-Negotiable Defaults

**PRINCIPLE: Code should read like a book - main story first, supporting details follow.**

### File Structure
```
1. Imports (all at top, no gaps)
2. Types/Interfaces (all together)
3. Constants (if any)
4. Main exports - the "what" this module does
5. Implementation details - the "how" it works
```

### CRITICAL RULES:
- **ALWAYS use `function` keyword** for module-level functions
- **NEVER use arrow functions** at module level (callbacks only)
- **Order functions for readability** - main purpose immediately visible
- **Function declarations give cleaner stack traces**

## Scope Guidelines

**Core Principle:** Make changes directly required to complete the task.

**SURGICAL EDITING:** When modifying existing code, make the smallest possible change that achieves the goal. Touch only the specific lines/functions that need modification.

**FILE EDITING BEHAVIOR (CRITICAL):**
- **ALWAYS edit existing files directly** - NEVER create "-improved", "-enhanced", "-v2", "-new", or similar versions
- **FORBIDDEN:** Creating copies/variants of existing files with suffixes like "-updated", "-fixed", "-refactored"
- **REQUIRED:** Use Edit/MultiEdit tools to modify files in place
- **Exception:** Only create new files when genuinely adding new functionality, not improving existing code

**Allowed:** Direct implementation, necessary imports/types, file creation when warranted, cleanup tasks
**Prohibited:** Unrelated refactoring, style changes, unrequested features, modifying unrelated code, creating file variants

## Refactoring and Backwards Compatibility (CRITICAL)

**DEFAULT BEHAVIOR: NO backwards compatibility preservation**

**When refactoring exports:**
- **REMOVE old exports** when replacing with new ones
- **DO NOT maintain deprecated exports** for backwards compatibility
- **DO NOT create compatibility shims or aliases**
- **ONLY preserve old exports if explicitly requested**

**Examples:**
```typescript
// ❌ WRONG - Don't do this unless asked
export function newFunction() { ... }
export const oldFunction = newFunction; // Backwards compat

// ✅ CORRECT - Clean refactor
export function newFunction() { ... }
// Old export removed entirely
```

**If backwards compatibility is needed, user will explicitly say:** "maintain backwards compatibility", "keep old exports", "preserve existing API"

## Avoiding Bad Assumptions (CRITICAL)

**NEVER assume - ALWAYS verify:**
- File names, paths, or directory structure
- Function/class/variable names without searching
- Library availability without checking package.json and imports
- Existing patterns without examining similar code
- What the user wants without asking for clarification
- That your first guess about implementation approach is correct

**When uncertain:**
1. **Search first** - Use grep/glob/ast-grep to find existing patterns
2. **Ask questions** - Clarify requirements before implementing
3. **Propose options** - Present alternatives when multiple approaches exist
4. **Verify dependencies** - Check package.json before using libraries
5. **Confirm breaking changes** - Ask before removing or significantly changing APIs

## Coding Conventions

**MANDATORY Discovery Process (before ANY implementation):**
1. Search for task-specific conventions in existing code
2. Check CLAUDE.md, AGENT.md, README.md, package.json, tsconfig.json
3. Study similar existing features
4. Verify library availability in package.json and existing imports
5. Understand naming patterns and project architecture
6. Search for existing implementations before writing new code

**IMPORTANT:** Skipping discovery means redoing work. Always understand existing patterns first.

**If you cannot find something after searching, say so explicitly** - don't assume it doesn't exist.

## Handling Uncertainty

**When you're unsure about:**
- **Implementation approach** → Present options and ask which the user prefers
- **Requirements** → Ask clarifying questions before implementing
- **Existing patterns** → Search exhaustively, then ask if not found
- **Breaking changes** → Explicitly confirm with user before proceeding
- **Library/API usage** → Check documentation or existing usage in codebase

**Default action when uncertain: ASK, don't assume.**

## Function Organization - Top-Down Flow

**KEY INSIGHT: Readers should understand module purpose from first few exports, not after scrolling through helpers.**

**CORRECT Pattern:**
```typescript
// All imports first (no blank lines between)
import { DataService } from './services';
import type { UserData, ProcessedUser } from './types';

// All types together
interface LocalConfig {
  apiUrl: string;
  timeout: number;
}

// Constants (if needed)
const DEFAULT_TIMEOUT = 5000;

// Main exports - purpose immediately clear
export async function fetchAndProcessUsers(config: LocalConfig): Promise<ProcessedUser[]> {
  const users = await fetchUsers(config);
  return processUsers(users);
}

export function processUsers(users: UserData[]): ProcessedUser[] {
  return users.map(user => ({
    ...user,
    displayName: formatUserName(user)
  }));
}

// Helper functions at bottom
function formatUserName(user: UserData): string {
  return `${user.name} <${user.email}>`;
}

async function fetchUsers(config: LocalConfig): Promise<UserData[]> {
  // Implementation
  return [];
}
```

**Type management:** Single use = colocate; 3+ files = shared type file

**Library usage:** NEVER assume availability - verify in package.json and existing imports

**Import patterns:** Static imports only (no `await import()` except for route splitting)

## Database and System Safety (CRITICAL)

**FORBIDDEN:** 
- Running migrations (`prisma migrate`, `db push`, etc.)
- Executing schema changes or raw SQL altering structure
- Running seed commands

**ALLOWED:** 
- Generating (not applying) migration files
- Reading data with SELECT/ORM reads
- Creating seed files (not running them)

**When asked about DB changes:** "I've created the migration file. You need to run `[command]` to apply it"

## Server Management (CRITICAL)

**FORBIDDEN:** Starting dev servers without explicit request (`npm run dev`, `yarn start`, etc.)

**When explicitly asked:** Confirm command, start server, monitor output

## Git Commit Management (CRITICAL)

**FORBIDDEN:** Creating git commits without explicit request (`git commit`, `git add`, etc.)

**NEVER commit changes unless the user explicitly asks you to.** It is VERY IMPORTANT to only commit when explicitly asked, otherwise the user will feel that you are being too proactive.

**When explicitly asked to commit:** Follow proper commit message conventions, stage appropriate files, create commit

## Implementation Planning

**When creating implementation plans:**
- **NEVER provide day or time estimates** (no "this will take X hours/days")
- **Focus on task breakdown** - List concrete steps and dependencies
- **Identify complexity** through technical details, not time
- **Describe effort** using relative terms: "straightforward", "complex", "requires careful consideration"
- **Highlight risks** and technical challenges without time implications

**Good planning format:**
```
1. Clear action items with technical specifics
2. Dependencies and prerequisites identified
3. Potential challenges or edge cases noted
4. Testing and validation steps included
```

**Avoid:**
- "This will take 2 days"
- "Approximately 4-6 hours"
- "Should be done by tomorrow"
- Any calendar or clock references

## Implementation Guidelines

**Code Reuse (CRITICAL):**
- **ALWAYS search for existing implementations before writing new code**
- NEVER copy/paste code - extract shared functions
- Use grep/glob/ast-grep to find similar patterns in codebase
- Refactor when patterns repeat 2+ times
- If similar functionality exists elsewhere, reuse or extract it

**Verification before implementation:**
- Search for existing utility functions that do what you need
- Check if the feature already exists in a different form
- Look for established patterns for the type of task you're doing

**Error handling:** Fix breakage as part of task

**Linter errors:** Remove unused variables entirely (no underscore prefix or ignore comments)

## Targeted Edits

**AI EDIT HERE / AEH:** Mark locations for implementation, always replace with actual code

## Command Shortcuts

- **AEH** - "AI EDIT HERE" marker
- **PEH** - Plan without implementing
- **mte** - Make all marked edits
- **c** - Continue
- **TODO** - Add to todo list

## Code Style Application

**New code:** MUST follow my patterns exactly
**Existing code:** Match their patterns for consistency
**Never mix styles in same file**

## Pre-Implementation Checklist

- [ ] Search for existing implementations of similar features
- [ ] Verify library availability in package.json
- [ ] Check existing conventions and patterns before writing
- [ ] Confirm understanding if requirements are unclear
- [ ] Use `function` keyword for module-level functions
- [ ] Organize top-down: main purpose first
- [ ] Make ONLY requested changes
- [ ] Fix any breakage caused

## Common Violations to AVOID

1. **Arrow functions at module level** - Use `function` keyword
2. **Poor organization** - Main exports first, helpers last
3. **Types scattered** - All types after imports
4. **Creating file variants** - NEVER create "-improved", "-enhanced", "-v2" versions; edit files directly
5. **Creating unnecessary files** - Edit existing when possible
6. **Unrelated refactoring** - Only requested changes
7. **Code duplication** - Extract shared functions
8. **Maintaining backwards compatibility** - Remove old exports unless explicitly asked
9. **Assuming without verifying** - Search for existing patterns before implementing
10. **Guessing file/function names** - Use search tools to find exact names
11. **Using unavailable libraries** - Check package.json first

## React Components

```typescript
// Imports
import React, { useState } from 'react';
import type { UserData } from './types';

// Types
interface UserCardProps {
  user: UserData;
  onUpdate: (user: UserData) => void;
}

// Component with function keyword
export function UserCard({ user, onUpdate }: UserCardProps) {
  const [isEditing, setIsEditing] = useState(false);
  
  return <div>{/* JSX */}</div>;
}

// Helpers at bottom
function validateUserData(data: unknown): data is UserData {
  // validation
}
```

## Comment Guidelines

**FORBIDDEN:** Obvious comments, explaining what code clearly does, "we/let's" language

**ONLY comment when:** Complex algorithms, non-obvious business logic, workarounds, performance optimizations

**Code should be self-documenting through clear naming and structure.**