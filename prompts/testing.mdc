---
description: Testing Philosophy and Patterns
globs: "**/*.{test,spec}.{ts,tsx,js,jsx}"
---

# Testing Rules

## Core Philosophy

**Tests verify behavior, not implementation.** A good test survives refactoring. If renaming an internal function breaks a test, it was testing implementation details.

**Prefer real code over mocks.** Every mock asserts how you *think* a dependency works, not how it *actually* works. Mocks drift from reality silently.

**Architecture:** Use "functional core, imperative shell" from base rules. Push logic into pure functions — trivially testable without mocks. Keep the imperative shell thin enough that integration tests suffice.

## Test Type Hierarchy

1. **Unit tests on pure functions** — fast, reliable, no setup, no mocks
2. **Integration tests** — real dependencies (test databases, in-memory stores)
3. **Component tests** — real components, mock only the network boundary (MSW)
4. **Mocking as last resort** — only for genuinely unavailable external systems

## What to Mock (and What NOT to Mock)

**Acceptable:** External third-party APIs, system clock, randomness, CI-unavailable resources

**NEVER mock:** Your own modules, database queries, internal function calls, framework internals

```typescript
// ❌ BRITTLE - Mocking your own code
jest.mock('./userService', () => ({
  getUser: jest.fn().mockResolvedValue({ id: '1', name: 'Test' })
}));

// ✅ CORRECT - Test actual functions with real inputs
const result = formatUserDisplay({ id: '1', name: 'Test', email: 'test@example.com' });
expect(result).toBe('Test <test@example.com>');

// ✅ CORRECT - Use MSW for network boundary
const server = setupServer(
  http.get('/api/users/:id', () => HttpResponse.json({ id: '1', name: 'Test' }))
);
```

## Anti-Patterns

- **Testing HOW not WHAT:** `expect(mock).toHaveBeenCalledWith(...)` breaks on refactor. Assert outputs instead.
- **Snapshot overuse:** `toMatchSnapshot()` is meaningless. Assert specific behavior.
- **Over-mocking:** 5+ mocks = too many dependencies. Refactor into functional core.

## Writing Tests That Last

1. **Name by behavior:** `'returns error when order has no items'` not `'test validateOrder'`
2. **One behavior per test** — if name has "and", split it
3. **Arrange-Act-Assert** — clear separation
4. **Use real data structures** — not minimal partial mocks
5. **Test edge cases in pure functions** — empty arrays, zero values, boundaries
