---
description: Locality of Behavior Principle
include: "**/*.{ts,tsx,js,jsx}"
---

# Locality of Behavior (LoB) Principle

**Core Principle:** The behavior of a unit of code should be as obvious as possible by looking only at that unit of code.

## Why LoB Matters
Making behavior obvious at the point of inspection reduces cognitive load, prevents bugs, and makes code maintainable. Avoid "spooky action at a distance" where understanding requires searching through multiple files.

## Good LoB in React

```typescript
// ✅ EXCELLENT - Behavior is obvious from inspection
export function UserCard({ user }: UserCardProps) {
  const [isEditing, setIsEditing] = useState(false);
  
  const handleSave = async () => {
    const response = await updateUser(user.id, formData);
    if (response.ok) {
      setIsEditing(false);
      toast.success('User saved');
    }
  };
  
  return (
    <div>
      {isEditing ? (
        <form onSubmit={handleSave}>
          <input name="name" defaultValue={user.name} />
          <button type="submit">Save</button>
        </form>
      ) : (
        <div onClick={() => setIsEditing(true)}>{user.name}</div>
      )}
    </div>
  );
}

// ✅ GOOD - Data fetching colocated with component
export function UserList() {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetchUsers()
      .then(setUsers)
      .finally(() => setLoading(false));
  }, []);
  
  if (loading) return <Spinner />;
  
  return (
    <div>
      {users.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
}
```

## Poor LoB in React

```typescript
// ❌ POOR - Behavior hidden in separate files/abstractions
// In UserCard.tsx:
export function UserCard({ user }: UserCardProps) {
  // What happens when this fires? Need to search the codebase
  useUserEditHandler(user.id);
  
  return <div className="user-card">{user.name}</div>;
}

// ❌ POOR - Event subscriptions hide behavior
// Somewhere in effects.ts:
eventBus.on('user:click', (userId) => {
  // Hidden side effect
  analytics.track('user_viewed', { userId });
  store.dispatch(loadUserDetails(userId));
});

// ❌ POOR - Global effects make behavior non-obvious
// In globalHooks.ts:
useEffect(() => {
  // Every component rerenders when this changes, but it's not obvious
  const unsub = authStore.subscribe(() => {
    forceGlobalRerender();
  });
  return unsub;
}, []);
```

## Balancing LoB with Other Principles

### LoB vs DRY
```typescript
// Sometimes repetition aids understanding
// ✅ GOOD - Obvious what each button does
<button onClick={() => deleteUser(user.id)}>Delete</button>
<button onClick={() => archiveUser(user.id)}>Archive</button>

// ❌ POOR - Abstraction hides behavior  
<ActionButton action="delete" target={user} />
<ActionButton action="archive" target={user} />
```

### LoB vs Separation of Concerns
```typescript
// ✅ GOOD - Related logic stays together
export function TodoItem({ todo }: TodoItemProps) {
  const [isComplete, setIsComplete] = useState(todo.complete);
  
  const toggleComplete = async () => {
    const newState = !isComplete;
    setIsComplete(newState);
    await updateTodo(todo.id, { complete: newState });
  };
  
  return (
    <div>
      <checkbox checked={isComplete} onChange={toggleComplete} />
      <span>{todo.text}</span>
    </div>
  );
}

// ❌ POOR - Logic scattered across files
// In TodoItem.tsx:
export function TodoItem({ todo }: TodoItemProps) {
  return (
    <div>
      <checkbox checked={todo.complete} />
      <span>{todo.text}</span>
    </div>
  );
}
// In todoHandlers.ts:
export function attachTodoHandlers() {
  document.querySelectorAll('.todo-checkbox').forEach(cb => {
    cb.addEventListener('change', handleTodoToggle);
  });
}
```

## Practical LoB Rules

1. **Event handlers:** Define inline or immediately above the JSX
2. **Side effects:** Keep useEffect close to the component it affects
3. **State management:** Prefer local state unless truly global
4. **Data fetching:** Colocate with components that need the data
5. **Form handling:** Keep validation and submission logic in the form component

## Custom Hooks and LoB

```typescript
// ✅ GOOD - Hook makes behavior obvious through naming and return values
export function useUserSearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState<User[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  
  const search = async (searchTerm: string) => {
    setQuery(searchTerm);
    setIsSearching(true);
    const users = await searchUsers(searchTerm);
    setResults(users);
    setIsSearching(false);
  };
  
  return { query, results, isSearching, search };
}

// Usage is obvious:
export function UserSearch() {
  const { query, results, isSearching, search } = useUserSearch();
  
  return (
    <div>
      <input 
        value={query}
        onChange={(e) => search(e.target.value)}
        placeholder="Search users..."
      />
      {isSearching && <Spinner />}
      {results.map(user => <UserCard key={user.id} user={user} />)}
    </div>
  );
}
```

## Distance Hierarchy
When behavior must be separated, minimize distance:
1. **Same function** (best)
2. **Same component** 
3. **Same file**
4. **Same directory**
5. **Separate module** (worst)

**Key Insight:** If someone needs to open multiple files to understand what a button does, you've created a maintenance burden. Optimize for the question "What does this do?" being immediately answerable.