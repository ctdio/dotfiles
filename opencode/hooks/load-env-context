#!/usr/bin/env bun

// OpenCode command helper: Crawl up directories to find .env files with opt-in marker
// and extract specific variables to inject into the prompt.
//
// Opt-in marker: A .env file must contain a comment line with:
//   # claude-env-inject
//
// Variables extracted (if present):
//   - POSTGRES_URL / DATABASE_URL
//   - INNGEST_BASE_URL
//   - (add more as needed)

const MARKER = "# claude-env-inject";
const MAX_DEPTH_UP = 5; // How many parent directories to crawl up

const VARIABLES_TO_EXTRACT = [
  "POSTGRES_URL",
  "DATABASE_URL",
  "INNGEST_BASE_URL",
  "INNGEST_EVENT_KEY",
  "INNGEST_SIGNING_KEY",
];

import { readFileSync, existsSync, readdirSync } from "fs";
import { dirname, join, resolve } from "path";

async function main() {
  const cwd = process.cwd();
  const envFiles = findEnvFiles(cwd);

  if (envFiles.length === 0) {
    process.exit(0);
  }

  const extractedVars: Record<string, { value: string; source: string }> = {};

  // Process files from root toward cwd (so closer files override)
  for (const envPath of envFiles.reverse()) {
    const content = readFileSync(envPath, "utf-8");

    // Check for opt-in marker
    if (!content.includes(MARKER)) {
      continue;
    }

    const vars = parseEnvFile(content);

    for (const varName of VARIABLES_TO_EXTRACT) {
      if (vars[varName]) {
        extractedVars[varName] = {
          value: vars[varName],
          source: envPath,
        };
      }
    }
  }

  if (Object.keys(extractedVars).length === 0) {
    process.exit(0);
  }

  const lines = ["Environment variables loaded from .env files:"];
  const sources = new Set<string>();

  for (const [name, { value, source }] of Object.entries(extractedVars)) {
    lines.push(`  ${name}=${value}`);
    sources.add(source);
  }

  lines.push("");
  lines.push(`Sources: ${[...sources].join(", ")}`);

  console.log(lines.join("\n"));
  process.exit(0);
}

function findEnvFiles(startDir: string): string[] {
  const envFiles: string[] = [];
  const resolvedStart = resolve(startDir);
  const root = "/";

  // 1. Check for .env in cwd
  const cwdEnv = join(resolvedStart, ".env");
  if (existsSync(cwdEnv)) {
    envFiles.push(cwdEnv);
  }

  // 2. Check 1-2 levels deep (without recursive glob which is slow)
  try {
    const entries = readdirSync(resolvedStart, { withFileTypes: true });

    for (const entry of entries) {
      if (!entry.isDirectory()) continue;
      // Skip common heavy directories
      if (entry.name === "node_modules" || entry.name === ".git" || entry.name === ".next" || entry.name === "dist" || entry.name === "build") continue;

      const level1Dir = join(resolvedStart, entry.name);
      const level1Env = join(level1Dir, ".env");
      if (existsSync(level1Env)) {
        envFiles.push(level1Env);
      }

      // Check level 2
      try {
        const level2Entries = readdirSync(level1Dir, { withFileTypes: true });
        for (const entry2 of level2Entries) {
          if (!entry2.isDirectory()) continue;
          if (entry2.name === "node_modules" || entry2.name === ".git") continue;

          const level2Env = join(level1Dir, entry2.name, ".env");
          if (existsSync(level2Env)) {
            envFiles.push(level2Env);
          }
        }
      } catch {}
    }
  } catch {}

  // 3. Crawl up to find .env files in parent directories (limited depth)
  let currentDir = dirname(resolvedStart);
  let depthUp = 0;
  while (currentDir !== root && depthUp < MAX_DEPTH_UP) {
    const envPath = join(currentDir, ".env");
    if (existsSync(envPath)) {
      envFiles.push(envPath);
    }

    const parentDir = dirname(currentDir);
    if (parentDir === currentDir) break;
    currentDir = parentDir;
    depthUp++;
  }

  return envFiles;
}

function parseEnvFile(content: string): Record<string, string> {
  const vars: Record<string, string> = {};

  for (const line of content.split("\n")) {
    const trimmed = line.trim();

    // Skip comments and empty lines
    if (!trimmed || trimmed.startsWith("#")) continue;

    // Match KEY=value or KEY="value" or KEY='value'
    const match = trimmed.match(/^([A-Z_][A-Z0-9_]*)=(.*)$/i);
    if (match) {
      const [, key, rawValue] = match;
      // Remove surrounding quotes if present
      let value = rawValue;
      if (
        (value.startsWith('"') && value.endsWith('"')) ||
        (value.startsWith("'") && value.endsWith("'"))
      ) {
        value = value.slice(1, -1);
      }
      vars[key] = value;
    }
  }

  return vars;
}

await main();
