#!/usr/bin/env bun

// SessionStart hook: Crawls up directories to find .env files with opt-in marker
// and extracts specific variables to inject into Claude's context.
//
// Opt-in marker: A .env file must contain a comment line with:
//   # claude-env-inject
//
// Variables extracted (if present):
//   - POSTGRES_URL / DATABASE_URL
//   - INNGEST_BASE_URL
//   - (add more as needed)

const MARKER = "# claude-env-inject";
const MAX_DEPTH_UP = 5; // How many parent directories to crawl up

const VARIABLES_TO_EXTRACT = [
  "POSTGRES_URL",
  "DATABASE_URL",
  "INNGEST_BASE_URL",
  "INNGEST_EVENT_KEY",
  "INNGEST_SIGNING_KEY",
];

import { readFileSync, existsSync, readdirSync } from "fs";
import { dirname, join, resolve } from "path";

async function main() {
  let payload;

  try {
    const raw = await readFromStdin();
    payload = JSON.parse(raw.trim());
  } catch (err) {
    // Silent fail - don't block session start
    process.exit(0);
  }

  const cwd = payload?.cwd || process.cwd();
  const envFiles = findEnvFiles(cwd);

  if (envFiles.length === 0) {
    process.exit(0);
  }

  const extractedVars: Record<string, { value: string; source: string }> = {};

  // Process files from root toward cwd (so closer files override)
  for (const envPath of envFiles.reverse()) {
    const content = readFileSync(envPath, "utf-8");

    // Check for opt-in marker
    if (!content.includes(MARKER)) {
      continue;
    }

    const vars = parseEnvFile(content);

    for (const varName of VARIABLES_TO_EXTRACT) {
      if (vars[varName]) {
        extractedVars[varName] = {
          value: vars[varName],
          source: envPath,
        };
      }
    }
  }

  if (Object.keys(extractedVars).length === 0) {
    process.exit(0);
  }

  // Build context message
  const lines = ["Environment variables loaded from .env files:"];
  const sources = new Set<string>();

  for (const [name, { value, source }] of Object.entries(extractedVars)) {
    lines.push(`  ${name}=${value}`);
    sources.add(source);
  }

  lines.push("");

  // Output as system message for Claude
  const output = {
    systemMessage: lines.join("\n"),
  };

  console.log(JSON.stringify(output));
  process.exit(0);
}

function findEnvFiles(startDir: string): string[] {
  const envFiles: string[] = [];
  const resolvedStart = resolve(startDir);
  const root = "/";

  // 1. Check for .env in cwd
  const cwdEnv = join(resolvedStart, ".env");
  if (existsSync(cwdEnv)) {
    envFiles.push(cwdEnv);
  }

  // 2. Check 1-2 levels deep (without recursive glob which is slow)
  try {
    const entries = readdirSync(resolvedStart, { withFileTypes: true });

    for (const entry of entries) {
      if (!entry.isDirectory()) continue;
      // Skip common heavy directories
      if (entry.name === "node_modules" || entry.name === ".git" || entry.name === ".next" || entry.name === "dist" || entry.name === "build") continue;

      const level1Dir = join(resolvedStart, entry.name);
      const level1Env = join(level1Dir, ".env");
      if (existsSync(level1Env)) {
        envFiles.push(level1Env);
      }

      // Check level 2
      try {
        const level2Entries = readdirSync(level1Dir, { withFileTypes: true });
        for (const entry2 of level2Entries) {
          if (!entry2.isDirectory()) continue;
          if (entry2.name === "node_modules" || entry2.name === ".git") continue;

          const level2Env = join(level1Dir, entry2.name, ".env");
          if (existsSync(level2Env)) {
            envFiles.push(level2Env);
          }
        }
      } catch {}
    }
  } catch {}

  // 3. Crawl up to find .env files in parent directories (limited depth)
  let currentDir = dirname(resolvedStart);
  let depthUp = 0;
  while (currentDir !== root && depthUp < MAX_DEPTH_UP) {
    const envPath = join(currentDir, ".env");
    if (existsSync(envPath)) {
      envFiles.push(envPath);
    }

    const parentDir = dirname(currentDir);
    if (parentDir === currentDir) break;
    currentDir = parentDir;
    depthUp++;
  }

  return envFiles;
}

function parseEnvFile(content: string): Record<string, string> {
  const vars: Record<string, string> = {};

  for (const line of content.split("\n")) {
    const trimmed = line.trim();

    // Skip comments and empty lines
    if (!trimmed || trimmed.startsWith("#")) continue;

    // Match KEY=value or KEY="value" or KEY='value'
    const match = trimmed.match(/^([A-Z_][A-Z0-9_]*)=(.*)$/i);
    if (match) {
      const [, key, rawValue] = match;
      // Remove surrounding quotes if present
      let value = rawValue;
      if (
        (value.startsWith('"') && value.endsWith('"')) ||
        (value.startsWith("'") && value.endsWith("'"))
      ) {
        value = value.slice(1, -1);
      }
      vars[key] = value;
    }
  }

  return vars;
}

async function readFromStdin(): Promise<string> {
  const timeout = (ms: number) => new Promise<string>((_, reject) =>
    setTimeout(() => reject(new Error("timeout")), ms)
  );

  const readStdin = async (): Promise<string> => {
    try {
      // @ts-ignore - Bun global may not be typed
      if (typeof Bun !== "undefined" && Bun.stdin) {
        // @ts-ignore - Bun specific API
        return await new Response(Bun.stdin).text();
      }
    } catch {}

    // Fallback to Node-style stdin
    return await new Promise<string>((resolve) => {
      let data = "";
      process.stdin.setEncoding("utf8");
      process.stdin.on("data", (chunk) => {
        data += chunk;
      });
      process.stdin.on("end", () => resolve(data));
      process.stdin.resume();
    });
  };

  return Promise.race([readStdin(), timeout(1000)]).catch(() => "{}");
}

await main();
