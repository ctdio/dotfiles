#!/usr/bin/env bun

// Ultrathink hook: Reads event payload from stdin, extracts `prompt`,
// and adds systematic thinking instructions when prompt starts or ends with -u

async function main() {
  let prompt = '';

  try {
    const raw = (await readFromStdin()).trim();
    if (raw.length > 0) {
      const payload = JSON.parse(raw);
      prompt = (payload?.prompt ?? '').toString().trim();
    }
  } catch (err) {
    console.error('Ultrathink hook: error reading from stdin', err);
    process.exit(2);
  }

  if (!prompt) {
    console.error('Ultrathink hook: no prompt provided via stdin or argv');
    process.exit(2);
  }

  if (prompt.startsWith('-u') || prompt.endsWith('-u')) {
    const output = {
      reason:
        'User submitted prompt with -u flag, which signals maximum ultrathink mode',
      hookSpecificOutput: {
        hookEventName: 'UserPromptSubmit',
        additionalContext:
          '[ultrathink] Use maximum thinking tokens and think systematically through this problem. Break down the request into components, consider edge cases, and reason through each step carefully before implementing.',
      },
    };

    console.log(JSON.stringify(output));
  }

  // Always exit successfully; absence of output means no-op for the hook
  process.exit(0);
}

async function readFromStdin(): Promise<string> {
  // Prefer Bun's Web Streams API when available
  try {
    // @ts-ignore - Bun global may not be typed
    if (typeof Bun !== 'undefined' && Bun.stdin) {
      // @ts-ignore - Bun specific API
      return await new Response(Bun.stdin).text();
    }
  } catch {}

  // Fallback to Node-style stdin
  return await new Promise<string>((resolve) => {
    let data = '';
    process.stdin.setEncoding('utf8');
    process.stdin.on('data', (chunk) => {
      data += chunk;
    });
    process.stdin.on('end', () => resolve(data));
    process.stdin.resume();
  });
}

await main();
