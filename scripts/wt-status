#!/bin/bash

# Show status of all git worktrees in opine/platform

PLATFORM_DIR="$HOME/projects/private/opine/platform"

# Colors
GREEN=$'\033[32m'
YELLOW=$'\033[33m'
RED=$'\033[31m'
DIM=$'\033[2m'
BOLD=$'\033[1m'
RESET=$'\033[0m'

# Check if platform dir exists
if [ ! -d "$PLATFORM_DIR" ]; then
  echo "${RED}Error:${RESET} $PLATFORM_DIR not found"
  exit 1
fi

# Get short commit hash for a worktree
get_short_hash() {
  git -C "$1" rev-parse --short HEAD 2>/dev/null
}

# Get branch name for a worktree
get_branch() {
  local branch
  branch=$(git -C "$1" symbolic-ref --short HEAD 2>/dev/null)
  if [ -z "$branch" ]; then
    branch="detached"
  fi
  echo "$branch"
}

# Check if worktree has uncommitted changes
is_dirty() {
  [ -n "$(git -C "$1" status --porcelain 2>/dev/null)" ]
}

# Parse git worktree list output
while read -r line; do
  # Format: /path/to/worktree  abc1234 [branch]
  path=$(echo "$line" | awk '{print $1}')

  [ -d "$path" ] || continue

  name=$(basename "$path")
  branch=$(get_branch "$path")
  hash=$(get_short_hash "$path")

  # Determine dirty status
  if is_dirty "$path"; then
    dirty="${RED}*${RESET}"
  else
    dirty=""
  fi

  # Color branch based on type
  if [ "$branch" = "main" ] || [ "$branch" = "master" ]; then
    branch_color="$GREEN"
  elif [ "$branch" = "detached" ]; then
    branch_color="$RED"
  else
    branch_color="$YELLOW"
  fi

  printf "${BOLD}%-20s${RESET} ${branch_color}%-30s${RESET} ${DIM}%s${RESET}%s\n" \
    "$name" "$branch" "$hash" "$dirty"

done < <(git -C "$PLATFORM_DIR" worktree list 2>/dev/null)
