#!/bin/bash

# Session switcher with branch information and server port detection
# Format: session_name [branch] :port1 :port2
# Preview: active pane content
#
# Usage:
#   session-switch-branch          Start fzf picker (ports load async)
#   session-switch-branch --list [ports]  Output session list to stdout

DIM=$'\033[2m'
RESET=$'\033[0m'
GREEN=$'\033[38;5;71m'
CYAN=$'\033[36m'
ORANGE=$'\033[38;5;208m'
TMPDIR="${TMPDIR:-/tmp}"
STALE_CACHE="$TMPDIR/wt-stale-sessions"
SELF="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"

current_session=$(tmux display-message -p '#S' 2>/dev/null)

# Fast branch lookup - reads .git/HEAD directly, handles worktrees
get_branch() {
  local dir="$1"
  local git_dir="$dir/.git"

  # Handle worktrees where .git is a file pointing to real git dir
  if [ -f "$git_dir" ]; then
    git_dir="${dir}/$(< "$git_dir")"
    git_dir="${git_dir#*gitdir: }"
  fi

  [ -f "$git_dir/HEAD" ] || return

  local head
  read -r head < "$git_dir/HEAD"
  if [[ "$head" == ref:\ refs/heads/* ]]; then
    echo "${head#ref: refs/heads/}"
  else
    echo "HEAD"
  fi
}

# --refresh-stale: check worktree branches for merged PRs, write to cache
if [[ "$1" == "--refresh-stale" ]]; then
  stale_dir=$(mktemp -d)
  trap 'rm -rf "$stale_dir"' EXIT
  pids=()

  while read -r session spath _ppath; do
    [[ "$session" =~ -wt[a-z]$ ]] || continue

    path="$spath"
    [ -n "$path" ] && [ -d "$path" ] || continue

    home_branch="${session##*-}"
    branch=$(get_branch "$path")
    [ -n "$branch" ] || continue
    [[ "$branch" == "$home_branch" ]] && continue

    gh_repo=$(git -C "$path" remote get-url origin 2>/dev/null | sed -E 's#(git@github\.com:|https://github\.com/)##; s#\.git$##')
    [ -n "$gh_repo" ] || continue

    (
      count=$(gh pr list --repo "$gh_repo" --head "$branch" --state merged --json number --limit 1 --jq 'length' 2>/dev/null)
      [ "$count" = "1" ] && echo "$session" > "$stale_dir/$session"
    ) &
    pids+=($!)
  done < <(tmux list-sessions -F '#{session_name} #{session_path} #{pane_current_path}' 2>/dev/null)

  for pid in "${pids[@]}"; do
    wait "$pid" 2>/dev/null || true
  done

  # Write cache atomically
  cat "$stale_dir"/* 2>/dev/null > "${STALE_CACHE}.tmp"
  mv "${STALE_CACHE}.tmp" "$STALE_CACHE" 2>/dev/null || rm -f "${STALE_CACHE}.tmp"
  exit 0
fi

# --list [ports]: output sorted session list to stdout
if [[ "$1" == "--list" ]]; then
  OUTFILE="$TMPDIR/session-list-$$"

  check_ports=false
  check_stale=false
  shift
  for arg in "$@"; do
    case "$arg" in
      ports) check_ports=true ;;
      stale) check_stale=true ;;
    esac
  done

  sessions=()
  paths=()
  is_current=()
  while read -r session spath ppath; do
    [[ "$session" == slot-* ]] && continue
    sessions+=("$session")
    is_current+=("$([[ "$session" = "$current_session" ]] && echo "1" || echo "0")")
    if [[ "$session" == slot-* ]]; then
      paths+=("$ppath")
    elif [ -n "$spath" ] && [ -d "$spath" ]; then
      paths+=("$spath")
    else
      paths+=("$ppath")
    fi
  done < <(tmux list-sessions -F '#{session_name} #{session_path} #{pane_current_path}' 2>/dev/null)

  # Port detection (only when requested)
  declare -A session_ports
  if $check_ports; then
    # Get listening port/pid pairs (cross-platform)
    list_listeners() {
      if command -v ss &>/dev/null; then
        ss -tlnp 2>/dev/null | awk '/LISTEN/ && /pid=/ {
          n = split($4, a, ":")
          port = a[n] + 0
          if (port >= 32768) next
          match($0, /pid=[0-9]+/)
          pid = substr($0, RSTART+4, RLENGTH-4)
          print port, pid
        }'
      elif command -v lsof &>/dev/null; then
        lsof -iTCP -sTCP:LISTEN -nP 2>/dev/null | awk 'NR > 1 {
          pid = $2 + 0
          n = split($9, a, ":")
          port = a[n] + 0
          if (port >= 49152) next
          print port, pid
        }'
      fi
    }

    listeners=$(list_listeners)
    if [ -n "$listeners" ]; then
      declare -A pid_to_session
      while read -r sess pid; do
        pid_to_session[$pid]=$sess
      done < <(tmux list-panes -a -F '#{session_name} #{pane_pid}')

      declare -A ppid_map
      while read -r pid ppid; do
        ppid_map[$pid]=$ppid
      done < <(ps -e -o pid=,ppid=)

      while read -r port pid; do
        current=$pid
        while [ -n "$current" ] && [ "$current" != "1" ] && [ "$current" != "0" ]; do
          if [ -n "${pid_to_session[$current]+x}" ]; then
            sess="${pid_to_session[$current]}"
            if [[ " ${session_ports[$sess]} " != *" $port "* ]]; then
              session_ports[$sess]+="${session_ports[$sess]:+ }$port"
            fi
            break
          fi
          current="${ppid_map[$current]}"
        done
      done <<< "$listeners"
    fi
  fi

  # Read stale session cache
  declare -A stale_sessions
  if [ -f "$STALE_CACHE" ]; then
    while read -r s; do
      [ -n "$s" ] && stale_sessions[$s]=1
    done < "$STALE_CACHE"
  fi

  for i in "${!sessions[@]}"; do
    session="${sessions[$i]}"
    path="${paths[$i]}"
    cur="${is_current[$i]}"
    ports="${session_ports[$session]}"
    is_stale="${stale_sessions[$session]:-}"
    {
      branch=$(get_branch "$path")
      port_display=""
      if [ -n "$ports" ]; then
        sorted_ports=$(echo "$ports" | tr ' ' '\n' | sort -n | tr '\n' ' ' | sed 's/ $//')
        port_display=" ${CYAN}:${sorted_ports// / :}${RESET}"
      fi
      stale_display=""
      if [ -n "$is_stale" ]; then
        stale_display=" ${ORANGE}merged${RESET}"
      fi
      if [ "$cur" = "1" ]; then
        if [ -n "$branch" ]; then
          printf "%s\t${GREEN}%s${RESET} ${DIM}[%s]${RESET}%s%s\n" "$session" "$session" "$branch" "$stale_display" "$port_display"
        else
          printf "%s\t${GREEN}%s${RESET}%s\n" "$session" "$session" "$port_display"
        fi
      else
        if [ -n "$branch" ]; then
          printf "%s\t%s ${DIM}[%s]${RESET}%s%s\n" "$session" "$session" "$branch" "$stale_display" "$port_display"
        else
          printf "%s\t%s%s\n" "$session" "$session" "$port_display"
        fi
      fi
    } >> "$OUTFILE" &
  done
  wait

  sort < "$OUTFILE" | cut -f2-
  rm -f "$OUTFILE"
  exit 0
fi

# Kick off stale PR check in background — results appear on next reload
"$SELF" --refresh-stale &
disown

# Main: show fzf immediately, async reload with ports + stale cache
selected=$("$SELF" --list | fzf \
  --ansi \
  --prompt="› " \
  --no-border \
  --bind "start:reload($SELF --list ports)" \
  --bind "ctrl-r:reload($SELF --list ports)" \
  --preview='
    session=$(echo {} | sed "s/\x1b\[[0-9;]*m//g; s/ .*//")
    tmux capture-pane -t "$session" -p -e 2>/dev/null | head -50
  ' \
  --preview-window=right:45%:noborder) || exit 0

if [ -n "$selected" ]; then
  session_name=$(echo "$selected" | sed 's/\x1b\[[0-9;]*m//g; s/ .*//')
  tmux switch-client -t "$session_name"
fi
