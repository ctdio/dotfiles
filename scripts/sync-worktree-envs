#!/bin/bash

# Script to sync .env files and Claude settings from main worktree to all other worktrees
# Usage: sync-worktree-envs [-v|--verbose] [--reset-dbs]
#
# Syncs:
# - platform/.env* -> platform-wt*/.env*
# - platform/apps/platform/.env* -> platform-wt*/apps/platform/.env*
# - platform/.claude/settings.local.json -> platform-wt*/.claude/settings.local.json
#
# Port Configuration:
# - After sync, PORT variable is updated per worktree
# - platform (source) keeps PORT=3000
# - Worktrees get ports based on their name suffix:
#   - Numeric: platform-wt1 -> 3001, platform-wt2 -> 3002
#   - Alpha: platform-wta -> 3001, platform-wtb -> 3002 (a=1, b=2, ...)
#
# Page Title:
# - NEXT_PUBLIC_PAGE_TITLE_PREFIX is updated per worktree
# - platform (source) uses "platform |" (or "platform-local |", etc.)
# - Worktrees replace "platform" prefix with suffix: "wta |", "wta-local |", etc.
#
# Database Configuration:
# - POSTGRES_DATABASE is updated per worktree for database isolation
# - platform (source) uses database "platform"
# - Worktrees use suffix as-is: platform_wt1, platform_wta, platform_wti, etc.
# - Use `db-worktree clone platform platform_wt<suffix>` to clone data
#
# Backups:
# - Stored in ~/.sync-worktree-backups (centralized, outside repo)
# - Organized by worktree and preserves directory structure
# - Only created when files differ (uses cmp to compare)
# - Claude settings are NOT backed up

set -e

# Parse arguments
VERBOSE=false
RESET_DBS=false
for arg in "$@"; do
    case $arg in
        -v|--verbose) VERBOSE=true ;;
        --reset-dbs) RESET_DBS=true ;;
    esac
done

# Detect OS for sed compatibility
if [[ "$OSTYPE" == "darwin"* ]]; then
    SED_INPLACE=(sed -i '')
else
    SED_INPLACE=(sed -i)
fi

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
DIM='\033[2m'
NC='\033[0m'

# Configuration
SOURCE_DIR="$HOME/projects/private/opine/platform"
BACKUP_DIR="${HOME}/.sync-worktree-backups"

# Logging functions
log_verbose() { [[ "$VERBOSE" == "true" ]] && echo -e "${DIM}$1${NC}"; }
log_warning() { echo -e "${YELLOW}⚠${NC} $1"; }
log_error() { echo -e "${RED}✗${NC} $1"; }

# Convert worktree suffix to slot number for ports (a=1, b=2, etc.)
get_worktree_slot() {
    local dir_name=$(basename "$1")
    if [[ "$dir_name" =~ ^platform-wt([0-9]+)$ ]]; then
        echo "${BASH_REMATCH[1]}"
    elif [[ "$dir_name" =~ ^platform-wt([a-z])$ ]]; then
        printf '%d' "$(($(printf '%d' "'${BASH_REMATCH[1]}") - 96))"
    fi
}

# Get worktree suffix for database names (preserves original: wti -> wti, wt1 -> wt1)
get_worktree_suffix() {
    local dir_name=$(basename "$1")
    if [[ "$dir_name" =~ ^platform-wt(.+)$ ]]; then
        echo "${BASH_REMATCH[1]}"
    fi
}

# Update port references in .env file
update_port_for_worktree() {
    local target_file="$1"
    local worktree_index="$2"

    [[ "$(basename "$target_file")" != ".env" ]] && return 0

    local new_port=$((3000 + worktree_index))
    local new_inngest_port=$((9000 + worktree_index))

    "${SED_INPLACE[@]}" "s/:3000/:$new_port/g" "$target_file" 2>/dev/null || true
    "${SED_INPLACE[@]}" "s/^PORT=3000/PORT=$new_port/g" "$target_file" 2>/dev/null || true
    "${SED_INPLACE[@]}" "s/\(INNGEST_BASE_URL.*\):8288/\1:$new_inngest_port/g" "$target_file" 2>/dev/null || true
}

# Update page title prefix in .env file
update_title_for_worktree() {
    local target_file="$1"
    local worktree_suffix="$2"

    [[ "$(basename "$target_file")" != ".env" ]] && return 0

    "${SED_INPLACE[@]}" 's/^\(NEXT_PUBLIC_PAGE_TITLE_PREFIX="\)platform/\1wt'"${worktree_suffix}"'/' "$target_file" 2>/dev/null || true
}

# Update database name in .env file
update_database_for_worktree() {
    local target_file="$1"
    local worktree_suffix="$2"

    [[ "$(basename "$target_file")" != ".env" ]] && return 0

    # Update main database references in URLs and variable
    "${SED_INPLACE[@]}" "s|:5432/platform|:5432/platform_wt${worktree_suffix}|g" "$target_file" 2>/dev/null || true
    "${SED_INPLACE[@]}" 's/^POSTGRES_DATABASE="platform"$/POSTGRES_DATABASE="platform_wt'"${worktree_suffix}"'"/' "$target_file" 2>/dev/null || true
    "${SED_INPLACE[@]}" 's/^POSTGRES_DATABASE=platform$/POSTGRES_DATABASE=platform_wt'"${worktree_suffix}"'/' "$target_file" 2>/dev/null || true

    # Update vector database references
    "${SED_INPLACE[@]}" "s|:5434/vector|:5434/vector_wt${worktree_suffix}|g" "$target_file" 2>/dev/null || true
    "${SED_INPLACE[@]}" 's/^POSTGRES_VECTOR_DATABASE="vector"$/POSTGRES_VECTOR_DATABASE="vector_wt'"${worktree_suffix}"'"/' "$target_file" 2>/dev/null || true
    "${SED_INPLACE[@]}" 's/^POSTGRES_VECTOR_DATABASE=vector$/POSTGRES_VECTOR_DATABASE=vector_wt'"${worktree_suffix}"'/' "$target_file" 2>/dev/null || true
}

# Reset databases for a worktree by cloning from source databases
reset_worktree_databases() {
    local suffix="$1"

    echo -e "${DIM}Resetting databases for wt${suffix}...${NC}"

    # Clone via docker exec to avoid client/server version mismatch
    db-branch -c platform-db clone platform "platform_wt${suffix}"
    db-branch -c platform-vector-db clone vector "vector_wt${suffix}"
}

# Sync a file with optional backup
sync_file() {
    local source_file="$1"
    local target_file="$2"
    local worktree_name="$3"
    local create_backup="${4:-true}"

    mkdir -p "$(dirname "$target_file")"

    # Create backup if target exists and differs
    if [[ "$create_backup" == "true" ]] && [[ -f "$target_file" ]] && ! cmp -s "$source_file" "$target_file"; then
        local backup_dir="$BACKUP_DIR/$(basename "$worktree_name")"
        mkdir -p "$backup_dir"
        cp "$target_file" "$backup_dir/$(basename "$target_file").backup.$(date +%Y%m%d-%H%M%S)"
        log_verbose "  Backed up $(basename "$target_file")"
    fi

    cp "$source_file" "$target_file"
}

# Validate source directory
if [[ ! -d "$SOURCE_DIR" ]]; then
    log_error "Source directory not found: $SOURCE_DIR"
    exit 1
fi

# Collect files to sync
ROOT_ENV_FILES=($(find "$SOURCE_DIR" -maxdepth 1 -name ".env*" -type f 2>/dev/null))
PLATFORM_APP_ENV_FILES=($(find "$SOURCE_DIR/apps/platform" -maxdepth 1 -name ".env*" -type f 2>/dev/null || true))
CLAUDE_SETTINGS_FILE=""
[[ -f "$SOURCE_DIR/.claude/settings.local.json" ]] && CLAUDE_SETTINGS_FILE="$SOURCE_DIR/.claude/settings.local.json"

TOTAL_SOURCE_FILES=$(( ${#ROOT_ENV_FILES[@]} + ${#PLATFORM_APP_ENV_FILES[@]} + ( ${#CLAUDE_SETTINGS_FILE} > 0 ? 1 : 0 ) ))

if [[ $TOTAL_SOURCE_FILES -eq 0 ]]; then
    log_warning "No files found to sync"
    exit 0
fi

# Get worktrees
if ! git -C "$SOURCE_DIR" worktree list &>/dev/null; then
    log_error "Cannot access git repository at $SOURCE_DIR"
    exit 1
fi

WORKTREES=()
while IFS= read -r line; do
    WORKTREES+=("$line")
done < <(git -C "$SOURCE_DIR" worktree list --porcelain | grep "^worktree " | cut -d' ' -f2 | tail -n +2)

if [[ ${#WORKTREES[@]} -eq 0 ]]; then
    log_warning "No worktrees found"
    exit 0
fi

# Sync to each worktree
SYNC_COUNT=0
ERROR_COUNT=0

for worktree in "${WORKTREES[@]}"; do
    SLOT=$(get_worktree_slot "$worktree")
    SUFFIX=$(get_worktree_suffix "$worktree")

    if [[ -z "$SLOT" ]]; then
        log_warning "Skipping unrecognized worktree: $(basename "$worktree")"
        continue
    fi

    wt_name=$(basename "$worktree")
    wt_files=0

    # Sync root .env files
    for env_file in "${ROOT_ENV_FILES[@]}"; do
        target_file="$worktree/$(basename "$env_file")"
        if sync_file "$env_file" "$target_file" "$worktree"; then
            update_port_for_worktree "$target_file" "$SLOT"
            update_database_for_worktree "$target_file" "$SUFFIX"
            update_title_for_worktree "$target_file" "$SUFFIX"
            ((wt_files++)) || true
        else
            ((ERROR_COUNT++)) || true
        fi
    done

    # Sync platform app .env files
    for env_file in "${PLATFORM_APP_ENV_FILES[@]}"; do
        target_file="$worktree/apps/platform/$(basename "$env_file")"
        if sync_file "$env_file" "$target_file" "$worktree"; then
            update_port_for_worktree "$target_file" "$SLOT"
            update_database_for_worktree "$target_file" "$SUFFIX"
            update_title_for_worktree "$target_file" "$SUFFIX"
            ((wt_files++)) || true
        else
            ((ERROR_COUNT++)) || true
        fi
    done

    # Sync Claude settings
    if [[ -n "$CLAUDE_SETTINGS_FILE" ]]; then
        if sync_file "$CLAUDE_SETTINGS_FILE" "$worktree/.claude/settings.local.json" "$worktree" false; then
            ((wt_files++)) || true
        else
            ((ERROR_COUNT++)) || true
        fi
    fi

    # Reset databases if requested
    if [[ "$RESET_DBS" == "true" ]]; then
        reset_worktree_databases "$SUFFIX"
    fi

    SYNC_COUNT=$((SYNC_COUNT + wt_files))
    echo -e "${GREEN}✓${NC} ${wt_name} ${DIM}(port 300${SLOT}, db platform_wt${SUFFIX})${NC}"
done

# Summary
if [[ $ERROR_COUNT -gt 0 ]]; then
    log_error "Synced $SYNC_COUNT files with $ERROR_COUNT errors"
    exit 1
fi
