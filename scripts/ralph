#!/bin/zsh

# Ralph Loop - Claude Code focused
#
# Runs Claude Code in a loop until completion promise is detected.
#
# Usage:
#   ralph "Build a todo API" --max-iterations 20 --completion-promise "DONE"
#   ralph -f prompt.md -m 10 -c "DONE"
#   ralph  # Interactive mode

set -euo pipefail

# Colors
RESET="\033[0m"
CYAN="\033[36m"
GREEN="\033[32m"
YELLOW="\033[33m"
RED="\033[31m"
DIM="\033[2m"

# Timing
TOTAL_START_TIME=0
ITERATION_START_TIME=0

# Ctrl-C protection
LAST_INTERRUPT=0

format_duration() {
  local seconds=$1
  if ((seconds < 60)); then
    echo "${seconds}s"
  elif ((seconds < 3600)); then
    local mins=$((seconds / 60))
    local secs=$((seconds % 60))
    if ((secs > 0)); then
      echo "${mins}m ${secs}s"
    else
      echo "${mins}m"
    fi
  else
    local hours=$((seconds / 3600))
    local mins=$(((seconds % 3600) / 60))
    local secs=$((seconds % 60))
    if ((secs > 0)); then
      echo "${hours}h ${mins}m ${secs}s"
    elif ((mins > 0)); then
      echo "${hours}h ${mins}m"
    else
      echo "${hours}h"
    fi
  fi
}

handle_interrupt() {
  local now
  now=$(date +%s)
  if ((now - LAST_INTERRUPT <= 2)); then
    echo -e "\n${RED}Interrupted${RESET}"
    # Clean up temp file if it exists
    [[ -n "${temp_output:-}" ]] && rm -f "$temp_output" 2>/dev/null
    # Print total time if we started
    if ((TOTAL_START_TIME > 0)); then
      local total_elapsed=$((now - TOTAL_START_TIME))
      echo -e "${DIM}total time: $(format_duration $total_elapsed)${RESET}"
    fi
    exit 130
  fi
  LAST_INTERRUPT=$now
  echo -e "\n${YELLOW}Press Ctrl-C again within 2s to exit${RESET}"
}

trap handle_interrupt SIGINT

# Stream parser location
STREAM_PARSER="${RALPH_STREAM_PARSER:-${CLAUDE_AGENT_STREAM_PARSER:-$HOME/dotfiles/shell-integrations/zsh/cc-stream-parser/cc-stream-parser}}"

# Defaults
MAX_ITERATIONS=10
COMPLETION_PROMISE="TASK_COMPLETE"
PROMPT=""
PROMPT_FILE=""
AGENT="claude"
AGENT_CMD_OVERRIDE="${RALPH_AGENT_CMD:-}"

print_help() {
  cat <<EOF
${CYAN}Ralph Loop${RESET}

Runs Claude Code in a loop until completion promise is detected.

${YELLOW}USAGE:${RESET}
  ralph "PROMPT" [OPTIONS]
  ralph  # Interactive mode

${YELLOW}OPTIONS:${RESET}
  -f, --file <path>               Read prompt from file
  -m, --max-iterations <n>        Maximum iterations (default: 10)
  -c, --completion-promise <text> Promise phrase to detect completion (default: TASK_COMPLETE)
  -a, --agent <claude|codex>      Agent preset to use (default: claude)
  -h, --help                      Show this help message

${YELLOW}EXAMPLES:${RESET}
  ralph "Build a todo API" --max-iterations 20 --completion-promise "DONE"
  ralph "Fix the auth bug" -m 10 -c "BUG FIXED"
  ralph -f ~/.ai/prompts/bugbot.md -m 10 -c "RESOLVED"

${YELLOW}COMPLETION:${RESET}
  Claude must output <promise>YOUR_PHRASE</promise> to signal completion.
  The promise must be TRUE - Claude should not lie to exit the loop.

${YELLOW}ENV VARS:${RESET}
  RALPH_AGENT_CMD     Full command string override (takes precedence over --agent)
  RALPH_STREAM_PARSER Stream parser command (set empty to disable parsing)
EOF
}

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      print_help
      exit 0
      ;;
    -f|--file)
      PROMPT_FILE="$2"
      shift 2
      ;;
    -m|--max-iterations)
      MAX_ITERATIONS="$2"
      shift 2
      ;;
    -c|--completion-promise)
      COMPLETION_PROMISE="$2"
      shift 2
      ;;
    -a|--agent)
      AGENT="$2"
      shift 2
      ;;
    *)
      if [[ -z "$PROMPT" ]]; then
        PROMPT="$1"
      else
        PROMPT="$PROMPT $1"
      fi
      shift
      ;;
  esac
done

# Read prompt from file if specified
if [[ -n "$PROMPT_FILE" ]]; then
  if [[ ! -f "$PROMPT_FILE" ]]; then
    echo -e "${RED}Error: File not found: $PROMPT_FILE${RESET}"
    exit 1
  fi
  PROMPT=$(cat "$PROMPT_FILE")
fi

# Interactive mode if no prompt provided
if [[ -z "$PROMPT" ]]; then
  echo -e "${CYAN}ralph${RESET}"
  echo "-------------------------------------"
  echo ""

  echo "Prompt:"
  PROMPT=""
  vared -p "> " PROMPT
  [[ -z "$PROMPT" ]] && echo "error: prompt required" && exit 1

  echo ""
  echo "Max iterations [10]:"
  local max_input=""
  vared -p "> " max_input
  MAX_ITERATIONS="${max_input:-10}"

  echo ""
  echo "Completion promise [TASK_COMPLETE]:"
  local promise_input=""
  vared -p "> " promise_input
  COMPLETION_PROMISE="${promise_input:-TASK_COMPLETE}"
  echo ""
fi

# Validate
if ! [[ "$MAX_ITERATIONS" =~ ^[0-9]+$ ]]; then
  echo -e "${RED}Error: max-iterations must be a number${RESET}"
  exit 1
fi

resolve_agent_cmd() {
  if [[ -n "$AGENT_CMD_OVERRIDE" ]]; then
    echo "$AGENT_CMD_OVERRIDE"
    return
  fi

  case "$AGENT" in
    claude)
      echo "claude --add-dir ~/.ai --dangerously-skip-permissions --output-format stream-json --include-partial-messages"
      ;;
    codex)
      echo "codex exec --json"
      ;;
    *)
      echo -e "${RED}Error: Unknown agent preset: $AGENT${RESET}"
      exit 1
      ;;
  esac
}

AGENT_CMD=$(resolve_agent_cmd)

# Check stream parser exists (only if set)
if [[ -n "$STREAM_PARSER" ]] && [[ ! -x "$STREAM_PARSER" ]]; then
  echo -e "${RED}Error: Stream parser not found at $STREAM_PARSER${RESET}"
  echo "Set RALPH_STREAM_PARSER to the path of a parser or empty to disable"
  exit 1
fi

build_prompt() {
  local iteration=$1
  cat <<EOF
$PROMPT

═══════════════════════════════════════════════════════════
RALPH LOOP CONTEXT - Iteration ${iteration}/${MAX_ITERATIONS}
═══════════════════════════════════════════════════════════

You are in a Ralph Loop. This means:
- Your output will be analyzed for completion
- If not complete, you'll receive the SAME PROMPT again
- Your previous work persists in files and git history

COMPLETION:
To signal completion, output this EXACT text:
  <promise>${COMPLETION_PROMISE}</promise>

STRICT REQUIREMENTS:
  ✓ Use <promise> XML tags EXACTLY as shown
  ✓ The statement MUST be completely and unequivocally TRUE
  ✓ Do NOT output false statements to exit the loop
  ✓ Do NOT lie even if you think you should exit

If stuck, keep trying. The loop continues until the promise is GENUINELY TRUE.
═══════════════════════════════════════════════════════════
EOF
}

check_completion() {
  local file="$1"
  # Check if file contains <promise>COMPLETION_PROMISE</promise>
  # Strip ANSI codes before checking to handle tool output bleeding
  if sed 's/\x1b\[[0-9;]*m//g' "$file" | grep -q "<promise>${COMPLETION_PROMISE}</promise>"; then
    return 0
  fi
  return 1
}

# Print header
echo -e "${CYAN}ralph${RESET}"
echo "-------------------------------------"
echo -e "agent:      ${AGENT}"
echo -e "iterations: ${MAX_ITERATIONS}"
echo -e "promise:    ${COMPLETION_PROMISE}"
echo ""
echo -e "prompt:     ${PROMPT}"
echo ""

# Start total timer
TOTAL_START_TIME=$(date +%s)

# Main loop
for ((iteration=1; iteration<=MAX_ITERATIONS; iteration++)); do
  echo -e "\n${CYAN}── iteration ${iteration}/${MAX_ITERATIONS} ──${RESET}\n"

  ITERATION_START_TIME=$(date +%s)
  augmented_prompt=$(build_prompt "$iteration")

  # Create temp file to capture output while streaming
  temp_output=$(mktemp)

  # Run agent with streaming JSON, pipe through parser when configured, capture output
  # Use || true to prevent script exit on ctrl-c (trap handles exit logic)
  local -a agent_cmd_parts=(${=AGENT_CMD})
  if [[ -n "$STREAM_PARSER" ]]; then
    "${agent_cmd_parts[@]}" "$augmented_prompt" 2>/dev/null | "$STREAM_PARSER" | tee "$temp_output" || true
  else
    "${agent_cmd_parts[@]}" "$augmented_prompt" 2>/dev/null | tee "$temp_output" || true
  fi

  # Calculate iteration duration
  iteration_end=$(date +%s)
  iteration_elapsed=$((iteration_end - ITERATION_START_TIME))
  echo -e "\n${DIM}iteration ${iteration} completed in $(format_duration $iteration_elapsed)${RESET}"

  # Check for completion (check file directly, stripping ANSI codes)
  if check_completion "$temp_output"; then
    rm -f "$temp_output"
    total_elapsed=$((iteration_end - TOTAL_START_TIME))
    echo -e "\n${GREEN}✓${RESET} Promise fulfilled after ${iteration} iteration(s)"
    echo -e "${DIM}total time: $(format_duration $total_elapsed)${RESET}"
    exit 0
  fi

  rm -f "$temp_output"

  if [[ $iteration -lt $MAX_ITERATIONS ]]; then
    echo -e "${YELLOW}Promise not detected. Continuing to next iteration...${RESET}"
  fi
done

total_elapsed=$(($(date +%s) - TOTAL_START_TIME))
echo -e "\n${RED}✗${RESET} Max iterations reached (${MAX_ITERATIONS}) · promise not fulfilled"
echo -e "${DIM}total time: $(format_duration $total_elapsed)${RESET}"
exit 1
